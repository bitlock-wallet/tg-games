{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/edine/OneDrive/Documents/BitLock-AI/tg-games/src/app/actions/upsertUserAndScore.ts"],"sourcesContent":["\"use server\";\r\n\r\nexport async function upsertUserAndScoreAction(\r\n  gameId: string,\r\n  userId: string,\r\n  score: number,\r\n  initData?: string | null\r\n) {\r\n  const { pgPool } = await import('../../db/drizzle');\r\n  const client = await pgPool.connect();\r\n  try {\r\n    console.log('[upsertUserAndScore] start', { gameId, userId, score, initData });\r\n    await client.query('BEGIN');\r\n\r\n    // Parse initData (URL query string) server-side to prefer authoritative user info\r\n    // initData format: key=value&... where 'user' may be a JSON-encoded value\r\n    let parsedUsername: string | null = null;\r\n    let parsedDisplayName: string | null = null;\r\n    try {\r\n      if (initData) {\r\n        const pairs = new URLSearchParams(initData);\r\n        const u = pairs.get('user');\r\n        if (u) {\r\n          try {\r\n            const parsed = JSON.parse(decodeURIComponent(u));\r\n            if (parsed) {\r\n              if (parsed.username) parsedUsername = String(parsed.username);\r\n              // prefer first_name as base for display name if username missing\r\n              if (parsed.first_name || parsed.last_name) parsedDisplayName = [parsed.first_name, parsed.last_name].filter(Boolean).join(' ');\r\n              // if username empty but display name available, use that as username as requested\r\n              if (!parsedUsername && parsedDisplayName) parsedUsername = parsedDisplayName;\r\n            }\r\n          } catch (err) {\r\n            // ignore parse errors\r\n            console.warn('[upsertUserAndScore] failed to parse initData user field', err, u);\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      // ignore\r\n    }\r\n\r\n    // Final fallbacks\r\n    const finalUsername = parsedUsername ?? `user-${userId}`;\r\n    const finalDisplayName = parsedDisplayName ?? finalUsername;\r\n    console.log('[upsertUserAndScore] resolved user info', { parsedUsername, parsedDisplayName, finalUsername, finalDisplayName });\r\n\r\n    const UPSERT_USER = `\r\n      INSERT INTO users (id, username, display_name)\r\n      VALUES ($1, $2, $3)\r\n      ON CONFLICT (id) DO UPDATE SET\r\n        username = EXCLUDED.username,\r\n        display_name = EXCLUDED.display_name\r\n      RETURNING id, username, display_name, created_at\r\n    `;\r\n\r\n    const userRes = await client.query(UPSERT_USER, [userId, finalUsername, finalDisplayName]);\r\n    console.log('[upsertUserAndScore] user upsert result rows:', userRes.rows);\r\n\r\n    const UPSERT_SCORE = `\r\n      INSERT INTO game_scores (game_id, user_id, username, score)\r\n      VALUES ($1, $2, $3, $4)\r\n      ON CONFLICT (game_id, user_id)\r\n      DO UPDATE SET score = GREATEST(game_scores.score, EXCLUDED.score), username = EXCLUDED.username, recorded_at = CURRENT_TIMESTAMP\r\n      RETURNING game_id, user_id, username, score\r\n    `;\r\n\r\n    const scoreRes = await client.query(UPSERT_SCORE, [gameId, userId, finalUsername, score]);\r\n    console.log('[upsertUserAndScore] score upsert result rows:', scoreRes.rows);\r\n\r\n    await client.query('COMMIT');\r\n\r\n    return {\r\n      user: userRes.rows && userRes.rows[0] ? userRes.rows[0] : null,\r\n      score: scoreRes.rows && scoreRes.rows[0] ? scoreRes.rows[0] : null,\r\n    };\r\n  } catch (e) {\r\n    try {\r\n      await client.query('ROLLBACK');\r\n    } catch (_) {\r\n      // ignore\r\n    }\r\n    throw e;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;IAEsB,2BAAA,WAAA,GAAA,IAAA,iWAAA,EAAA,8CAAA,sVAAA,EAAA,KAAA,GAAA,4VAAA,EAAA","debugId":null}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/edine/OneDrive/Documents/BitLock-AI/tg-games/node_modules/.pnpm/next%4016.0.1_%40babel%2Bcore%407.2_048eab391ea2e03c70ee64ac0670005b/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-client-wrapper.ts"],"sourcesContent":["// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nexport { callServer } from 'next/dist/client/app-call-server'\nexport { findSourceMapURL } from 'next/dist/client/app-find-source-map-url'\n\n// A noop wrapper to let the Flight client create the server reference.\n// See also: https://github.com/facebook/react/pull/26632\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createServerReference } from 'react-server-dom-webpack/client'\n"],"names":["callServer","createServerReference","findSourceMapURL"],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;;;;;;;;;;;;;;;;IAEjBA,UAAU,EAAA;eAAVA,eAAAA,UAAU;;IAMVC,qBAAqB,EAAA;eAArBA,QAAAA,qBAAqB;;IALrBC,gBAAgB,EAAA;eAAhBA,qBAAAA,gBAAgB;;;+BADE;qCACM;wBAKK","ignoreList":[0],"debugId":null}}]
}